"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionEnvelope = void 0;
const tslib_1 = require("tslib");
const web3_js_1 = require("@solana/web3.js");
const PendingTransaction_1 = require("./PendingTransaction");
/**
 * Contains a Transaction that is being built.
 */
class TransactionEnvelope {
    constructor(provider, instructions, signers = []) {
        this.provider = provider;
        this.instructions = instructions;
        this.signers = signers;
    }
    addSigners(...signers) {
        this.signers.push(...signers);
        return this;
    }
    /**
     * Builds a transaction from this envelope.
     */
    build() {
        return new web3_js_1.Transaction().add(...this.instructions);
    }
    /**
     * Simulates the transaction.
     * @param opts
     * @returns
     */
    simulate(opts) {
        return this.provider.simulate(this.build(), this.signers, opts);
    }
    /**
     * Sends the transaction.
     * @param opts
     * @returns
     */
    send(opts) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const sig = yield this.provider.send(this.build(), this.signers, opts);
            return new PendingTransaction_1.PendingTransaction(this.provider, sig);
        });
    }
    /**
     * Sends the transaction and waits for confirmation.
     * @param opts
     */
    confirm(opts) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            return (yield this.send(opts)).wait();
        });
    }
    /**
     * Combines the instructions/signers of the other envelope to create one large transaction.
     */
    combine(other) {
        return new TransactionEnvelope(this.provider, [...this.instructions, ...other.instructions], [...this.signers, ...other.signers]);
    }
    /**
     * Get a list of all writable accounts, deduped
     * All of these accounts likely need to be updated after the transaction is confirmed.
     */
    get writableKeys() {
        return [
            ...new Set([
                ...this.instructions
                    .map((inst) => inst.keys.filter((key) => key.isWritable).map((k) => k.pubkey))
                    .reduce((acc, el) => acc.concat(el)),
            ]).values(),
        ];
    }
    /**
     * Gets the instructions in a format that can be serialized easily to JSON.
     */
    get instructionsJSON() {
        return this.instructions.map((instruction) => ({
            programId: instruction.programId.toString(),
            keys: instruction.keys.map((m) => ({
                isSigner: m.isSigner,
                isWritable: m.isWritable,
                publicKey: m.pubkey.toString(),
            })),
            data: instruction.data.toString("base64"),
        }));
    }
    /**
     * Returns a string representation of the {@link TransactionEnvelope}.
     */
    get debugStr() {
        return [
            "=> Instructions",
            this.instructions
                .map((ser, i) => {
                return [
                    `Instruction ${i}: ${ser.programId.toString()}`,
                    ...ser.keys.map((k, i) => `  [${i}] ${k.pubkey.toString()} ${k.isWritable ? "(mut)" : ""} ${k.isSigner ? "(signer)" : ""}`),
                    `  Data (base64): ${ser.data.toString("base64")}`,
                ].join("\n");
            })
                .join("\n"),
            "=> Signers",
            this.signers.map((sg) => sg.publicKey.toString()).join("\n"),
        ].join("\n");
    }
    /**
     * Combines multiple TransactionEnvelopes into one.
     */
    static combineAll(...txs) {
        return txs.reduce((acc, tx) => acc.combine(tx));
    }
    /**
     * Combines multiple async TransactionEnvelopes into one, serially.
     */
    static combineAllAsync(firstTX, ...txs) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            let acc = yield firstTX;
            for (const tx of txs) {
                acc = acc.combine(yield tx);
            }
            return acc;
        });
    }
    /**
     * Sends all of the envelopes.
     * @returns Pending transactions
     */
    static sendAll(txs, opts) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const firstTX = txs[0];
            if (!firstTX) {
                return [];
            }
            const provider = firstTX.provider;
            const txSigs = yield provider.sendAll(txs.map((tx) => ({ tx: tx.build(), signers: tx.signers })), opts);
            return txSigs.map((sig) => new PendingTransaction_1.PendingTransaction(provider, sig));
        });
    }
}
exports.TransactionEnvelope = TransactionEnvelope;
//# sourceMappingURL=TransactionEnvelope.js.map