import type { AccountMeta, ConfirmOptions, PublicKey, RpcResponseAndContext, Signer, SimulatedTransactionResponse, TransactionInstruction } from "@solana/web3.js";
import { Transaction } from "@solana/web3.js";
import type { Provider } from "../interfaces";
import { PendingTransaction } from "./PendingTransaction";
import type { TransactionReceipt } from "./TransactionReceipt";
export interface SerializableInstruction {
    programId: string;
    keys: (Omit<AccountMeta, "pubkey"> & {
        publicKey: string;
    })[];
    data: string;
}
/**
 * Contains a Transaction that is being built.
 */
export declare class TransactionEnvelope {
    readonly provider: Provider;
    readonly instructions: TransactionInstruction[];
    readonly signers: Signer[];
    constructor(provider: Provider, instructions: TransactionInstruction[], signers?: Signer[]);
    addSigners(...signers: Signer[]): TransactionEnvelope;
    /**
     * Builds a transaction from this envelope.
     */
    build(): Transaction;
    /**
     * Simulates the transaction.
     * @param opts
     * @returns
     */
    simulate(opts?: ConfirmOptions): Promise<RpcResponseAndContext<SimulatedTransactionResponse>>;
    /**
     * Sends the transaction.
     * @param opts
     * @returns
     */
    send(opts?: ConfirmOptions): Promise<PendingTransaction>;
    /**
     * Sends the transaction and waits for confirmation.
     * @param opts
     */
    confirm(opts?: ConfirmOptions): Promise<TransactionReceipt>;
    /**
     * Combines the instructions/signers of the other envelope to create one large transaction.
     */
    combine(other: TransactionEnvelope): TransactionEnvelope;
    /**
     * Get a list of all writable accounts, deduped
     * All of these accounts likely need to be updated after the transaction is confirmed.
     */
    get writableKeys(): PublicKey[];
    /**
     * Gets the instructions in a format that can be serialized easily to JSON.
     */
    get instructionsJSON(): SerializableInstruction[];
    /**
     * Returns a string representation of the {@link TransactionEnvelope}.
     */
    get debugStr(): string;
    /**
     * Combines multiple TransactionEnvelopes into one.
     */
    static combineAll(...txs: TransactionEnvelope[]): TransactionEnvelope;
    /**
     * Combines multiple async TransactionEnvelopes into one, serially.
     */
    static combineAllAsync(firstTX: Promise<TransactionEnvelope>, ...txs: Promise<TransactionEnvelope>[]): Promise<TransactionEnvelope>;
    /**
     * Sends all of the envelopes.
     * @returns Pending transactions
     */
    static sendAll(txs: TransactionEnvelope[], opts?: ConfirmOptions): Promise<PendingTransaction[]>;
}
//# sourceMappingURL=TransactionEnvelope.d.ts.map