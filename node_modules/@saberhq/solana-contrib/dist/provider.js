"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolanaProvider = exports.SolanaReadonlyProvider = exports.DEFAULT_PROVIDER_OPTIONS = void 0;
const tslib_1 = require("tslib");
const web3_js_1 = require("@solana/web3.js");
const utils_1 = require("./utils");
exports.DEFAULT_PROVIDER_OPTIONS = {
    preflightCommitment: "recent",
    commitment: "recent",
};
/**
 * Provider that can only read.
 */
class SolanaReadonlyProvider {
    /**
     * @param connection The cluster connection where the program is deployed.
     * @param sendConnection The connection where transactions are sent to.
     * @param wallet     The wallet used to pay for and sign all transactions.
     * @param opts       Transaction confirmation options to use by default.
     */
    constructor(connection, opts = exports.DEFAULT_PROVIDER_OPTIONS) {
        this.connection = connection;
        this.opts = opts;
    }
    /**
     * Gets
     * @param accountId
     * @returns
     */
    getAccountInfo(accountId) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const accountInfo = yield this.connection.getAccountInfo(accountId, this.opts.commitment);
            if (!accountInfo) {
                return null;
            }
            return {
                accountId,
                accountInfo,
            };
        });
    }
}
exports.SolanaReadonlyProvider = SolanaReadonlyProvider;
/**
 * The network and wallet context used to send transactions paid for and signed
 * by the provider.
 *
 * This implementation was taken from Anchor.
 */
class SolanaProvider extends SolanaReadonlyProvider {
    /**
     * @param connection The cluster connection where the program is deployed.
     * @param sendConnection The connection where transactions are sent to.
     * @param wallet     The wallet used to pay for and sign all transactions.
     * @param opts       Transaction confirmation options to use by default.
     */
    constructor(connection, sendConnection, wallet, opts = exports.DEFAULT_PROVIDER_OPTIONS) {
        super(connection, opts);
        this.connection = connection;
        this.sendConnection = sendConnection;
        this.wallet = wallet;
        this.opts = opts;
    }
    /**
     * Sends the given transaction, paid for and signed by the provider's wallet.
     *
     * @param tx      The transaction to send.
     * @param signers The set of signers in addition to the provdier wallet that
     *                will sign the transaction.
     * @param opts    Transaction confirmation options.
     */
    send(tx, signers, opts) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            if (signers === undefined) {
                signers = [];
            }
            if (opts === undefined) {
                opts = this.opts;
            }
            tx.feePayer = this.wallet.publicKey;
            tx.recentBlockhash = (yield this.sendConnection.getRecentBlockhash(opts.preflightCommitment)).blockhash;
            yield this.wallet.signTransaction(tx);
            signers
                .filter((s) => s !== undefined)
                .forEach((kp) => {
                tx.partialSign(kp);
            });
            const rawTx = tx.serialize();
            const txId = yield (0, web3_js_1.sendAndConfirmRawTransaction)(this.sendConnection, rawTx, opts);
            return txId;
        });
    }
    /**
     * Similar to `send`, but for an array of transactions and signers.
     */
    sendAll(reqs, opts) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            return yield (0, utils_1.sendAll)({
                provider: this,
                reqs,
                opts: opts !== null && opts !== void 0 ? opts : this.opts,
                confirm: true,
            });
        });
    }
    /**
     * Simulates the given transaction, returning emitted logs from execution.
     *
     * @param tx      The transaction to send.
     * @param signers The set of signers in addition to the provdier wallet that
     *                will sign the transaction.
     * @param opts    Transaction confirmation options.
     */
    simulate(tx, signers, opts) {
        var _a, _b;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            if (signers === undefined) {
                signers = [];
            }
            if (opts === undefined) {
                opts = this.opts;
            }
            tx.feePayer = this.wallet.publicKey;
            tx.recentBlockhash = (yield this.connection.getRecentBlockhash((_a = opts.preflightCommitment) !== null && _a !== void 0 ? _a : this.opts.preflightCommitment)).blockhash;
            yield this.wallet.signTransaction(tx);
            signers
                .filter((s) => s !== undefined)
                .forEach((kp) => {
                tx.partialSign(kp);
            });
            return yield (0, utils_1.simulateTransactionWithCommitment)(this.connection, tx, (_b = opts.commitment) !== null && _b !== void 0 ? _b : this.opts.commitment);
        });
    }
}
exports.SolanaProvider = SolanaProvider;
//# sourceMappingURL=provider.js.map