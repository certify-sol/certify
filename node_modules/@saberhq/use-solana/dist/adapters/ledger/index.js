"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LedgerError = exports.LedgerWalletAdapter = void 0;
const tslib_1 = require("tslib");
const hw_transport_webusb_1 = (0, tslib_1.__importDefault)(require("@ledgerhq/hw-transport-webusb"));
const eventemitter3_1 = (0, tslib_1.__importDefault)(require("eventemitter3"));
const types_1 = require("../types");
const core_1 = require("./core");
const DEFAULT_DERIVATION_PATH = (0, core_1.getSolanaDerivationPath)();
class LedgerWalletAdapter extends eventemitter3_1.default {
    constructor() {
        super();
        this._connecting = false;
        this._publicKey = null;
        this._transport = null;
        this._derivationPath = DEFAULT_DERIVATION_PATH;
    }
    get publicKey() {
        return this._publicKey || types_1.DEFAULT_PUBLIC_KEY;
    }
    get connected() {
        return this._publicKey !== null;
    }
    get autoApprove() {
        return false;
    }
    signAllTransactions(transactions) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const result = [];
            for (let i = 0; i < transactions.length; i++) {
                const transaction = transactions[i];
                if (transaction) {
                    const signed = yield this.signTransaction(transaction);
                    result.push(signed);
                }
            }
            return result;
        });
    }
    signTransaction(transaction) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            if (!this._transport || !this._publicKey) {
                throw new Error("Not connected to Ledger");
            }
            const signature = yield (0, core_1.signTransaction)(this._transport, transaction, this._derivationPath);
            transaction.addSignature(this._publicKey, signature);
            return transaction;
        });
    }
    connect(args) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            if (this._connecting) {
                return;
            }
            this._connecting = true;
            try {
                // @TODO: transport selection (WebUSB, WebHID, bluetooth, ...)
                this._transport = yield hw_transport_webusb_1.default.create();
                if (args) {
                    const { account, change } = args;
                    this._derivationPath = (0, core_1.getSolanaDerivationPath)(account, change);
                    this._publicKey = yield (0, core_1.getPublicKey)(this._transport, this._derivationPath);
                }
                else {
                    this._publicKey = yield (0, core_1.getPublicKey)(this._transport);
                }
                this.emit("connect", this._publicKey);
            }
            catch (error) {
                yield this.disconnect();
                throw new LedgerError(error);
            }
            finally {
                this._connecting = false;
            }
        });
    }
    disconnect() {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            let emit = false;
            if (this._transport) {
                yield this._transport.close();
                this._transport = null;
                emit = true;
            }
            this._connecting = false;
            this._publicKey = null;
            if (emit) {
                this.emit("disconnect");
            }
        });
    }
    /**
     * Ledger transport.
     */
    get transport() {
        return this._transport;
    }
    /**
     * Fetches accounts associated with the given derivation paths.
     *
     * @param paths
     * @returns
     */
    static fetchAccountsForPaths(paths) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            let transport = null;
            try {
                transport = yield hw_transport_webusb_1.default.create();
                const ret = [];
                for (const path of paths) {
                    const derivationPath = (0, core_1.getSolanaDerivationPath)(path.account, path.change);
                    ret.push(Object.assign(Object.assign({}, path), { key: yield (0, core_1.getPublicKey)(transport, derivationPath) }));
                }
                return ret;
            }
            catch (error) {
                throw new LedgerError(error);
            }
            finally {
                yield (transport === null || transport === void 0 ? void 0 : transport.close());
            }
        });
    }
}
exports.LedgerWalletAdapter = LedgerWalletAdapter;
class LedgerError extends Error {
    constructor(error) {
        super(`Ledger Error: ${error.message}`);
        this.name = "LedgerError";
    }
}
exports.LedgerError = LedgerError;
//# sourceMappingURL=index.js.map